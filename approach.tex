% !TeX root = main.tex
% !TeX spellcheck = de_DE
% !TeX encoding = utf8

\chapter{Approach}
My architecture is somewhat based on  Yanhuan Liu, Chun Zhang, Pengcheng Song, and Hanjun Jiang\cite{LiZh17} paper. Although I change the stored values. For a message parsing LDPC decoder the straightforward implementation is to store the messages sent between the check and parity nodes. This results in needing to store multiple values per row of the parity check matrix. For example the LDPC code used for 802.11n with block length 1926 \todo{find nice source for 802.11n codes}and rate 0.5 has row weights of 7 and 8. This requires to store 8 messages per row of the parity check matrix. The approach I chose is only suited to the min-sum algorithm and will result in a reduction of storage requirements. Instead of splitting the iteration at the message step it is in this case preferable to split at the minimum and the sum for the variable node calculation.

For decoding the are two message types. The message from the variable nodes to the check nodes $q_{nm}$ and the message going the other way $r_{nm}$. Decoding is done in different steps\cite{EmEl14}:

\begin{enumerate}
\item{Initialization}\\
The values from the channel are converted to LLRs $y_n$. These initial LLR values used as $q_{nm}$ the input to the first check node.

\item{Check Node Step}\\
Each check node $m$ receives the messages from the variable nodes and calculates its response message.
\begin{equation}
    r_{mn} = \left( \prod_{n' \in M(m)\\n}\sign(q_{n'm}) \right) \min_{n' \in vn\{m\}\\n}(\left|q_{n'm}\right|)
\end{equation}

\item{Variable node step}\\
Each variable node $n$ receives the messages from the check nodes and calculates its response message.
\begin{equation}
    q_{nm} = y_n + \sum_{m' \in N(n)\\ m}r_{m'n}
\end{equation}

\item{Output Descision}\\
The result LLR values are updated.
\begin{equation}
    L_n = y_n + \sum_{m \in N(n)}r_{m'n}
\end{equation}

\end{enumerate}

Instead of storing all the messages it is also possible to store the sign, the minimum, and the sum over all messages directed to a column of variable nodes. When storing the minimum it is not enough to just store the minimum. This arises due to the fact that each minimum calculation excludes the current check node. Therefore I store the smallest, the second smallest, and the position of the smallest number. The notation $\min^2$ is for the smallest argument but not including the element $min$ returns. If I call the minimum $s$, the second smallest $t$, the product of all signs $v$, and the id $k$, I get the check node step split into two:

\begin{align}
    s(m) & = \min_{n' \in M(m)}(\left|q_{n'm}\right|) \label{cn_min}\\
    t(m) & = \min_{n' \in M(m)}^2(\left|q_{n'm}\right|) \label{cn_min2}\\
    k(m) & = \argmin (\left|q_{n'm}\right|) \label{cn_min_id}\\
    v(m) & =  \prod_{n' \in M(m)}\sign(q_{n'm}) \label{cn_sign}
\end{align}

And for the check node calculation I can use the results from \cref{cn_min,cn_min2,cn_min_id,cn_sign} to simplify the calculations for each check node.
\begin{equation}
    r_{mn} = v(m) \sign(q_{nm}) c_{mn}
\end{equation}
with
\begin{equation}
    c_{mn} = \begin{cases}
        t(m), & \text{for } n = k(m) \\
        s(m), & \text{else}
    \end{cases}
\end{equation}

In the variable node step I instead calculate the sum over all messages:

\begin{equation}
    S(n) = y_n + \sum_{m \in N(n)}r_{m'n} 
\end{equation}

