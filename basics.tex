% !TeX root = main.tex
% !TeX spellcheck = de_DE
% !TeX encoding = utf8

\chapter{Error Correcting Codes}

For modern communications systems reliable data transmission and storage ist required. To achieve this goal usually error correcting codes are used. There are different possible codes available for error correction, but I will restrain myself to LDPC\cite{Ga63} codes in this thesis. As these codes can archive good performance and can be used at large block lengths\cite{TaSc2017}. This is especially useful for use with NAND based solid state drives.

When describing a block code there are important parameters as the message length $k$. The message is what is given into the encoder and the result from the decoder. The block length $n$, and the rate $R = k / n$. 


\section{Low-Density Parity-Check (LDPC) Codes}

The following section will describe LDPC codes invented by Robert Gallager\cite{Ga63}. Starting with a graph representation I will describe the LDPC code and then continue with a matrix representation. LDPC codes can be shown as a bipartite graph also called Tanner graph\cite{Ta81} based on their inventor. \cref{tanner_ex} shows an example of one, where the check and parity nodes are connected by edges. This is an effective representation, moreover it will also help understanding the decoding algorithm later.

\begin{figure}
	\begin{tikzpicture}[
		cnode/.style={draw,rectangle,node distance=.5cm,align=center,minimum width=.5cm, minimum height=.5cm},
		vnode/.style={draw,circle,node distance=.5cm,align=center,minimum width=.5cm, minimum height=.5cm}
		]
		\node (vn) [vnode] {};
		\node [right=of vn] {code Symbols (variable nodes)};
		\node (cn) [below=of vn,cnode] {};
		\node [right=of cn] {parity equations (check nodes)};
	\end{tikzpicture}
	
	\begin{tikzpicture}[
		cnode/.style={draw,rectangle,node distance=1cm,align=center,minimum width=.5cm, minimum height=.5cm},
		vnode/.style={draw,circle,node distance=1cm,align=center,minimum width=.5cm, minimum height=.5cm}
	]
	\begin{scope}[start chain=going right, node distance=15mm]
		\node [vnode, on chain] (v0) {};
		\node [vnode, on chain] (v1) {};
		\node [vnode, on chain] (v2) {};
		\node [vnode, on chain] (v3) {};
		\node [vnode, on chain] (v4) {};
		\node [vnode, on chain] (v5) {};
		\node [vnode, on chain] (v6) {};
		\node [vnode, on chain] (v7) {};
	\end{scope}
	\begin{scope}[start chain=going right, node distance=15mm]
		\node [cnode, on chain, above=2cm of v2] (c0) {};
		\node [cnode, on chain] (c1) {};
		\node [cnode, on chain] (c2) {};
		\node [cnode, on chain] (c3) {};
	\end{scope}
	\draw (c0) -- (v1);
	\draw (c0) -- (v3);
	\draw (c0) -- (v4);	
	\draw (c0) -- (v7);
	\draw (c1) -- (v0);
	\draw (c1) -- (v1);
	\draw (c1) -- (v2);
	\draw (c1) -- (v5);
	\draw (c2) -- (v2);
	\draw (c2) -- (v5);
	\draw (c2) -- (v6);
	\draw (c2) -- (v7);
	\draw (c3) -- (v0);
	\draw (c3) -- (v3);
	\draw (c3) -- (v4);
	\draw (c3) -- (v6);
	\end{tikzpicture}
	\centering
	\caption{An example Tanner graph.}
	\label{tanner_ex}
\end{figure}

Instead of using the Tanner graph one can also use a matrix representation. In this matrix the ones represent the edges of the graph. Usually for a LDPC code the matrix is sparse or low density as the name implies. In \cref{ldpc_mat} a matrix representing the same code as in the graph in \cref{tanner_ex} is shown. The $\bm{H}$ matrix is of size $(n-k) x n$. And the possible code words are given by the null space of $\bm{H}$, so in other words $c$ is a code word if and only if $c\bm{H}^T = \bm{0}$\cite{RiUr01}.


\begin{equation}
	\bm{H} = \left[\begin{matrix}
		0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 \\ 
		1 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\
		0 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\
		1 & 0 & 0 & 1 & 1 & 0 & 1 & 0
	\end{matrix}\right] \label{ldpc_mat}
\end{equation}

\subsection{Encoding}
\subsubsection{Genrator Matrix}
For encoding the probably simplest algorithm is transforming the parity check matrix into systematic form $\bm{H} = \left[\begin{matrix} \bm{-A^T} & \bm{I_{n-k}}\end{matrix}\right]$. Where $\bm{I_{n-k}}$ is a $n-k \times n - k$ identity matrix and $\bm{A}$ has $k \times n - k$ elements. To archive this form one could for example use gaussian elimination. With $\bm{A}$ known we can construct the generator matrix $\bm{G} = \left[\begin{matrix} \bm{I_{k}} & \bm{A} \end{matrix}\right]$. Now encoding can be done with a simple matrix multiplication. With $u$ the information word and $v$ the code word is given by $v = u \bm{G}$.

Take for example the matrix from \cref{ldpc_mat}. If we use gaussian elimination to bring the right side to identity we are left with \cref{ldpc_ident}. Now we take the left part of the matrix and transpose it to get $\bm{A}$. With we build $\bm{G}$ in \cref{ldpc_gen}.

\begin{align}
	\bm{H} = \left[\begin{matrix}
		0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 \\
		1 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\
		1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 \\
		0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
	\end{matrix} \right] \label{ldpc_ident} \\
	\bm{G} = \left[\begin{matrix}
		0 & 1 & 1 & 0 & 1 & 0 & 0 & 0 \\
 		1 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\
 		0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 \\
 		1 & 0 & 0 & 0 & 0 & 0 & 0 & 1
	\end{matrix} \right] \label{ldpc_gen}
\end{align}

The main disadvantage of this strategy is the high computational complexity. When transforming the parity check matrix into systematic form we have a complexity of $\mathcal{O}(n^3)$. This is not to bad as it will mostly be done offline and only the $\bm{G}$ matrix stored in the encoder, but the bigger problem is that due to the gaussian elimination the matrix is no longer sparse. Thus the matrix multiplication will result in a complexity of $\mathcal{O}(n^2)$\cite{QiGo07}. 

\subsubsection{Approximate Lower Triangular Form}
\cite{RiUr01} describe a way to reorder the parity check matrix to reduce the encoding complexity. They bring the matrix into a so called approximate lower triangular form. This is done by only doing row and column permutation, so the low density of the matrix is kept.

\begin{figure}
	\begin{tikzpicture}[
		style1/.style={
				matrix of math nodes,
				every node/.append style={text width=#1,align=center,minimum height=3ex},
				nodes in empty cells,
				left delimiter=[,
				right delimiter=],
			}
		]
		\matrix[style1=0.3cm] (1mat) {
			& & & & & & & & & & & & & & & \\
			& & & & & & & & & & & & & & & \\
			& & & & & & & & & & & & & & & \\
			& & & & & & & & & & & & & & & \\
			& & & & & & & & & & & & & & & \\
			& & & & & & & & & & & & & & & \\
			& & & & & & & & & & & & & & & \\
			& & & & & & & & & & & & & & & \\
		};
		\draw[dashed] (1mat-5-1.south west) -- (1mat-5-16.south east);
		\draw[dashed] (1mat-1-11.north east) -- (1mat-8-11.south east);
		\draw[dashed] (1mat-1-8.north east) -- (1mat-8-8.south east);

		\node [font=\Large] at ($(1mat-3-4)!0.5!(1mat-3-5)$) {A};
		\node [font=\Large] at (1mat-3-10) {B};

		\node [font=\Large] at (1mat-4-13) {T};
		\node [font=\Large] at (1mat-2-15) {0};

		\node [font=\Large] at ($(1mat-7-4)!0.5!(1mat-7-5)$) {C};
		\node [font=\Large] at (1mat-7-10) {D};

		\node at (1mat-1-12) {1};
		\node at (1mat-2-13) {1};
		\node at (1mat-3-14) {1};
		\node at (1mat-4-15) {1};
		\node at (1mat-5-16) {1};
		


	\end{tikzpicture}
	\centering
\end{figure}

\chapter{Field Programmable Gate Array (FPGA)}
\todo{write some basics about FPGA}